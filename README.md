# classification-of-metastases

## Ноутбуки:
**first_look_at_data.ipynb** - первый взгляд на данные, тут есть картинки данных и первая попытка их загружать в np.array 

**Data preparing.ipynb** - ноутбук, где производится обработка данных для создания датасетов с 2D и 3D изображениями с размерностями [60,512,512] и [3,20, 512, 512] соответсвнно.

**2D_experiments.ipynb** - ноутбук с нейронной сетью, обученной на 2D данных

## Файлы:
**dataset.py** - файл, содержаший класс для загрузки датасет (наследуется от DatasetFolder)

**transforms.py** - файл, содержащий трансофрамции для использования в dataloader

## Результаты экспериментов:

Сначала рассмотрим как выглядят наши данные:
![data](/pictures/data_example.png)

### 2D сеть

Первые эксперименты мы провели с 2D сетью и получили точность ~ 90% на тестовой выборке  (результаты есть в ноутбуке)

Функция ошибки везде: CrossEntropyLoss.

На первой картинке представлены значения функции потери по каждой итерации на 30 эпохах с batch_size 10

![2D](/pictures/2D_30epoch.png)

На этой картинки представлены значения функции потери с использования кросс валидации (обучение на 10 эпохах 5 раз)

![2D_fold](/pictures/2D_fold.png)

На представленном ниже графике можно увидеть ROC кривую для этого классификатора и из него четко видно что качество классификации на обоих классах очень хорошее.



![2D_ROC](/pictures/ROC_2D.png)

### 3D сеть

Результаты обучения 3D сети сопоставимы с результатами обучения 2D сети, точность более стабильна по ходу обучения и достигает таких же значений, однако обучение горадо более долгое.

На первой картинке представлены значения функции потери по каждой итерации на 20 эпохах с batch_size 10

![3D](/pictures/3D_20epoch.png)

На этой картинки представлены значения функции потери с использования кросс валидации (обучение на 5 эпохах 5 раз)

![3D_fold](/pictures/3D_fold.png)

Однако общее качество классификации модели оказалось довольно плохим оценивая её по ROC кривой, мы предполагаем что это из-за того, что сеть в общем обучалась меньше чем предыдущая и архитектура в целом проще чем у 2D классификатора. 

![3D_ROC](/pictures/ROC_3D.png)

